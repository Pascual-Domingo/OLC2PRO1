{"version":3,"sources":["./$_lazy_route_resource lazy namespace object","./src/app/app-routing.module.ts","./src/app/app.component.ts","./src/app/app.component.html","./src/app/app.module.ts","./src/app/graficar/graficar.component.ts","./src/app/graficar/graficar.component.html","./src/app/interprete/grammar.js","./src/app/interprete/instrucciones.ts","./src/app/interprete/recorridoAST.ts","./src/app/interprete/tabla_simbolos.ts","./src/app/navegation/navegation.component.ts","./src/app/navegation/navegation.component.html","./src/app/traductor/traductor.component.ts","./src/app/traductor/traductor.component.html","./src/environments/environment.ts","./src/main.ts","fs (ignored)","path (ignored)"],"names":[],"mappings":"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4F;AACA;AACA;AACA,2F;AACA;AACA;AACA,6F;AACA;AACA;AACA,iF;AACA;AACA;AACA,yE;AACA;AACA;AACA,iE;AACA;AACA;AACA,mB;AACA;AACA;AACA,6F;AACA;AACA;AACA,6F;AACA;AACA;AACA,+F;AACA;AACA;AACA,+F;AACA;AACA;AACA,+F;AACA;AACA;AACA,4F;AACA;AACA;AACA,iB;AACA;AACA;AACA,uF;AACA;AACA;AACA,sF;AACA;AACA;AACA,4E;AACA;AACA;AACA,CAAC;AACD,SAAS,gFAAgF,EAAE,MAAM,EAAE,0BAA0B,EAAE,6EAA6E,eAAe,4DAA4D,8BAA8B,0CAA0C,GAAG,sDAAsD,wEAAwE,sDAAsD,EAAE,QAAQ,EAAE,6EAA6E,EAAE,6EAA6E,gBAAgB,2DAA2D,EAAE,2DAA2D,EAAE,2DAA2D,EAAE,2DAA2D,EAAE,2DAA2D,EAAE,2DAA2D,EAAE,sDAAsD,EAAE,sDAAsD,EAAE,sDAAsD,EAAE,sDAAsD,EAAE,sDAAsD,EAAE,sDAAsD,gBAAgB,oDAAoD,gCAAgC,OAAO,mGAAmG,4BAA4B,eAAe,4BAA4B,eAAe,OAAO,eAAe,OAAO,gBAAgB,OAAO;AACluD,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,mBAAO,CAAC,8DAAiB;AAC/C,qBAAqB,mBAAO,CAAC,gEAAkB,YAAY;AAC3D,wBAAwB,mBAAO,CAAC,8DAAiB;AACjD,0BAA0B,mBAAO,CAAC,8DAAiB;AACnD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iCAAiC;AACjC,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL,qDAAqD;AACrD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL,UAAU,oCAAoC;AAC9C;AACA;AACA;AACA,kB;AACA;AACA,kB;AACA;AACA,kB;AACA;AACA,kB;AACA;AACA,iB;AACA;AACA,kB;AACA;AACA,kB;AACA;AACA,kB;AACA;AACA,kB;AACA;AACA,kB;AACA;AACA,mB;AACA;AACA,mB;AACA;AACA,mB;AACA;AACA,mB;AACA;AACA,mB;AACA;AACA,mB;AACA;AACA,mB;AACA;A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","file":"main.js","sourcesContent":["function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(function() {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = function() { return []; };\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nmodule.exports = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = \"./$$_lazy_route_resource lazy recursive\";","import { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { TraductorComponent } from './traductor/traductor.component';\n\nconst routes: Routes = [\n  {\n    path: '',\n    redirectTo: '/traductor',\n    pathMatch: 'full'\n  },\n  {\n    path: 'traductor',\n    component: TraductorComponent\n  }\n\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n","import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'OLC2PRO1';\n}\n","<app-navegation></app-navegation>\n<router-outlet></router-outlet>","import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { NavegationComponent } from './navegation/navegation.component';\nimport { TraductorComponent } from './traductor/traductor.component';\nimport { GraficarComponent } from './graficar/graficar.component';\nimport { FormsModule } from '@angular/forms';\nimport { CodemirrorModule } from '@ctrl/ngx-codemirror';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    NavegationComponent,\n    TraductorComponent,\n    GraficarComponent\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    FormsModule,\n    CodemirrorModule,\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n","import { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-graficar',\n  templateUrl: './graficar.component.html',\n  styleUrls: ['./graficar.component.css']\n})\nexport class GraficarComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit(): void {\n  }\n\n}\n","<p>graficar works!</p>\n","/* parser generated by jison 0.4.18 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar grammar = (function(){\nvar o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,13],$V1=[1,7],$V2=[1,8],$V3=[1,9],$V4=[1,10],$V5=[1,11],$V6=[1,12],$V7=[1,3],$V8=[1,5],$V9=[1,15],$Va=[5,34,35],$Vb=[5,28,29,30,31,32,33,34,35],$Vc=[1,24],$Vd=[1,25],$Ve=[1,26],$Vf=[1,27],$Vg=[1,28],$Vh=[1,29],$Vi=[5,11,16,17,18,19,20,21,28,29,30,31,32,33,34,35],$Vj=[5,11,16,17,28,29,30,31,32,33,34,35],$Vk=[5,11,16,17,18,19,20,28,29,30,31,32,33,34,35];\nvar parser = {trace: function trace () { },\nyy: {},\nsymbols_: {\"error\":2,\"Init\":3,\"EXP_LOGICA\":4,\"EOF\":5,\"LINSTRUCCIONES\":6,\"INSTRUCCION\":7,\"timprimir\":8,\"parA\":9,\"EXP\":10,\"parC\":11,\"ptcoma\":12,\"tif\":13,\"llaveA\":14,\"llaveC\":15,\"mas\":16,\"menos\":17,\"por\":18,\"div\":19,\"modular\":20,\"exponente\":21,\"entero\":22,\"decimal\":23,\"cadena1\":24,\"cadena2\":25,\"cadena3\":26,\"EXP_RELACIONAL\":27,\"mayque\":28,\"menque\":29,\"mayigque\":30,\"menigque\":31,\"igig\":32,\"noig\":33,\"and\":34,\"or\":35,\"not\":36,\"ttrue\":37,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",5:\"EOF\",8:\"timprimir\",9:\"parA\",11:\"parC\",12:\"ptcoma\",13:\"tif\",14:\"llaveA\",15:\"llaveC\",16:\"mas\",17:\"menos\",18:\"por\",19:\"div\",20:\"modular\",21:\"exponente\",22:\"entero\",23:\"decimal\",24:\"cadena1\",25:\"cadena2\",26:\"cadena3\",28:\"mayque\",29:\"menque\",30:\"mayigque\",31:\"menigque\",32:\"igig\",33:\"noig\",34:\"and\",35:\"or\",36:\"not\",37:\"ttrue\"},\nproductions_: [0,[3,2],[6,2],[6,1],[7,5],[7,7],[10,3],[10,3],[10,3],[10,3],[10,3],[10,3],[10,2],[10,1],[10,1],[10,1],[10,1],[10,1],[10,3],[27,3],[27,3],[27,3],[27,3],[27,3],[27,3],[27,1],[4,3],[4,3],[4,2],[4,1],[4,1]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1:\n return $$[$0-1]; \nbreak;\ncase 2:\n $$[$0-1].push($$[$0]); this.$ = S1; \nbreak;\ncase 3:\n this.$ = [S1]; \nbreak;\ncase 4:\n this.$ = instruccionesAPI.nuevoImprimir($$[$0-2]); \nbreak;\ncase 5:\n this.$ = instruccionesAPI.nuevoIf($$[$0-4], $$[$0-1]); \nbreak;\ncase 6:\n this.$ = instruccionesAPI.nuevoOperacionBinaria($$[$0-2], $$[$0], TIPO_OPERACION.SUMA); \nbreak;\ncase 7:\n this.$ = instruccionesAPI.nuevoOperacionBinaria($$[$0-2], $$[$0], TIPO_OPERACION.RESTA); \nbreak;\ncase 8:\n this.$ = instruccionesAPI.nuevoOperacionBinaria($$[$0-2], $$[$0], TIPO_OPERACION.MULTIPLICACION); \nbreak;\ncase 9:\n this.$ = instruccionesAPI.nuevoOperacionBinaria($$[$0-2], $$[$0], TIPO_OPERACION.DIVISION); \nbreak;\ncase 10:\n this.$ = instruccionesAPI.nuevoOperacionBinaria($$[$0-2], $$[$0], TIPO_OPERACION.MODULAR); \nbreak;\ncase 11:\n this.$ = instruccionesAPI.nuevoOperacionBinaria($$[$0-2], $$[$0], TIPO_OPERACION.EXPONENTE); \nbreak;\ncase 12:\n this.$ = instruccionesAPI.nuevoOperacionUnaria($$[$0], TIPO_OPERACION.NEGATIVO); \nbreak;\ncase 13: case 14:\n this.$ = instruccionesAPI.nuevoValor(Number($$[$0]), TIPO_VALOR.NUMERO); \nbreak;\ncase 15: case 16: case 17:\n this.$ = instruccionesAPI.nuevoValor($$[$0], TIPO_VALOR.CADENA); \nbreak;\ncase 18:\n this.$ = $$[$0-1]; \nbreak;\ncase 19:\n this.$ = instruccionesAPI.nuevoOperacionBinaria($$[$0-2], $$[$0], TIPO_OPERACION.MAYOR_QUE); \nbreak;\ncase 20:\n this.$ = instruccionesAPI.nuevoOperacionBinaria($$[$0-2], $$[$0], TIPO_OPERACION.MENOR_QUE); \nbreak;\ncase 21:\n this.$ = instruccionesAPI.nuevoOperacionBinaria($$[$0-2], $$[$0], TIPO_OPERACION.MAYOR_IGUAL); \nbreak;\ncase 22:\n this.$ = instruccionesAPI.nuevoOperacionBinaria($$[$0-2], $$[$0], TIPO_OPERACION.MENOR_IGUAL); \nbreak;\ncase 23:\n this.$ = instruccionesAPI.nuevoOperacionBinaria($$[$0-2], $$[$0], TIPO_OPERACION.DOBLE_IGUAL); \nbreak;\ncase 24:\n this.$ = instruccionesAPI.nuevoOperacionBinaria($$[$0-2], $$[$0], TIPO_OPERACION.NO_IGUAL); \nbreak;\ncase 25: case 29:\n this.$ = $$[$0]; \nbreak;\ncase 26:\n this.$ = instruccionesAPI.nuevoOperacionBinaria($$[$0-2], $$[$0], TIPO_OPERACION.AND); \nbreak;\ncase 27:\n this.$ = instruccionesAPI.nuevoOperacionBinaria($$[$0-2], $$[$0], TIPO_OPERACION.OR); \nbreak;\ncase 28:\n this.$ = instruccionesAPI.nuevoOperacionUnaria($$[$0], TIPO_OPERACION.NOT); \nbreak;\n}\n},\ntable: [{3:1,4:2,9:$V0,10:6,17:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6,27:4,36:$V7,37:$V8},{1:[3]},{5:[1,14],34:$V9,35:[1,16]},{4:17,9:$V0,10:6,17:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6,27:4,36:$V7,37:$V8},o($Va,[2,29],{28:[1,18],29:[1,19],30:[1,20],31:[1,21],32:[1,22],33:[1,23]}),o($Va,[2,30]),o($Vb,[2,25],{16:$Vc,17:$Vd,18:$Ve,19:$Vf,20:$Vg,21:$Vh}),{9:$V0,10:30,17:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6},o($Vi,[2,13]),o($Vi,[2,14]),o($Vi,[2,15]),o($Vi,[2,16]),o($Vi,[2,17]),{9:$V0,10:31,17:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6},{1:[2,1]},{4:32,9:$V0,10:6,17:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6,27:4,36:$V7,37:$V8},{4:33,9:$V0,10:6,17:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6,27:4,36:$V7,37:$V8},o($Va,[2,28]),{9:$V0,10:6,17:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6,27:34},{9:$V0,10:6,17:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6,27:35},{9:$V0,10:6,17:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6,27:36},{9:$V0,10:6,17:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6,27:37},{9:$V0,10:6,17:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6,27:38},{9:$V0,10:6,17:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6,27:39},{9:$V0,10:40,17:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6},{9:$V0,10:41,17:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6},{9:$V0,10:42,17:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6},{9:$V0,10:43,17:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6},{9:$V0,10:44,17:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6},{9:$V0,10:45,17:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6},o($Vi,[2,12]),{11:[1,46],16:$Vc,17:$Vd,18:$Ve,19:$Vf,20:$Vg,21:$Vh},o($Va,[2,26]),o([5,35],[2,27],{34:$V9}),o($Vb,[2,19]),o($Vb,[2,20]),o($Vb,[2,21]),o($Vb,[2,22]),o($Vb,[2,23]),o($Vb,[2,24]),o($Vj,[2,6],{18:$Ve,19:$Vf,20:$Vg,21:$Vh}),o($Vj,[2,7],{18:$Ve,19:$Vf,20:$Vg,21:$Vh}),o($Vk,[2,8],{21:$Vh}),o($Vk,[2,9],{21:$Vh}),o($Vk,[2,10],{21:$Vh}),o($Vi,[2,11]),o($Vi,[2,18])],\ndefaultActions: {14:[2,1]},\nparseError: function parseError (str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        var error = new Error(str);\n        error.hash = hash;\n        throw error;\n    }\n},\nparse: function parse(input) {\n    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    var args = lstack.slice.call(arguments, 1);\n    var lexer = Object.create(this.lexer);\n    var sharedState = { yy: {} };\n    for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n            sharedState.yy[k] = this.yy[k];\n        }\n    }\n    lexer.setInput(input, sharedState.yy);\n    sharedState.yy.lexer = lexer;\n    sharedState.yy.parser = this;\n    if (typeof lexer.yylloc == 'undefined') {\n        lexer.yylloc = {};\n    }\n    var yyloc = lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = lexer.options && lexer.options.ranges;\n    if (typeof sharedState.yy.parseError === 'function') {\n        this.parseError = sharedState.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    _token_stack:\n        var lex = function () {\n            var token;\n            token = lexer.lex() || EOF;\n            if (typeof token !== 'number') {\n                token = self.symbols_[token] || token;\n            }\n            return token;\n        };\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n                    if (typeof action === 'undefined' || !action.length || !action[0]) {\n                var errStr = '';\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push('\\'' + this.terminals_[p] + '\\'');\n                    }\n                }\n                if (lexer.showPosition) {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\\n' + lexer.showPosition() + '\\nExpecting ' + expected.join(', ') + ', got \\'' + (this.terminals_[symbol] || symbol) + '\\'';\n                } else {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\\'' + (this.terminals_[symbol] || symbol) + '\\'');\n                }\n                this.parseError(errStr, {\n                    text: lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected\n                });\n            }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(lexer.yytext);\n            lstack.push(lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n                if (recovering > 0) {\n                    recovering--;\n                }\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n                yyval._$.range = [\n                    lstack[lstack.length - (len || 1)].range[0],\n                    lstack[lstack.length - 1].range[1]\n                ];\n            }\n            r = this.performAction.apply(yyval, [\n                yytext,\n                yyleng,\n                yylineno,\n                sharedState.yy,\n                action[1],\n                vstack,\n                lstack\n            ].concat(args));\n            if (typeof r !== 'undefined') {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}};\n\n\tconst TIPO_VALOR \t\t= require('./instrucciones').TIPO_VALOR;\n\tconst TIPO_DATO\t\t\t= require('./tabla_simbolos').TIPO_DATO; //para jalar el tipo de dato\n\tconst TIPO_OPERACION\t= require('./instrucciones').TIPO_OPERACION;\n\tconst instruccionesAPI\t= require('./instrucciones').instruccionesAPI;\n/* generated by jison-lex 0.3.4 */\nvar lexer = (function(){\nvar lexer = ({\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function(match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex () {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin (condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState () {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules () {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState (n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState (condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {\"flex\":true,\"case-insensitive\":true},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0: return 16; \nbreak;\ncase 1: return 17; \nbreak;\ncase 2: return 18; \nbreak;\ncase 3: return 19; \nbreak;\ncase 4: return 9; \nbreak;\ncase 5: return 11; \nbreak;\ncase 6: return 14; \nbreak;\ncase 7: return 15; \nbreak;\ncase 8: return 12; \nbreak;\ncase 9: return 28; \nbreak;\ncase 10: return 29; \nbreak;\ncase 11: return 30; \nbreak;\ncase 12: return 31; \nbreak;\ncase 13: return 32; \nbreak;\ncase 14: return 33; \nbreak;\ncase 15: return 36; \nbreak;\ncase 16: return 20; \nbreak;\ncase 17: return 21; \nbreak;\ncase 18: return 13; \nbreak;\ncase 19: return 8; \nbreak;\ncase 20: return 37; \nbreak;\ncase 21: return 23; \nbreak;\ncase 22: return 22; \nbreak;\ncase 23: yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2); return 24; \nbreak;\ncase 24: yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2); return 25; \nbreak;\ncase 25: yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2); return 26; \nbreak;\ncase 26:/* skip whitespace */\nbreak;\ncase 27:// comentario simple línea\nbreak;\ncase 28:// comentario multiple líneas\nbreak;\ncase 29:return 5 //fin de cadena\nbreak;\ncase 30:console.log(yy_.yytext);\nbreak;\n}\n},\nrules: [/^(?:(\\+))/i,/^(?:(-))/i,/^(?:(\\*))/i,/^(?:(\\/))/i,/^(?:(\\())/i,/^(?:(\\)))/i,/^(?:(\\{))/i,/^(?:(\\}))/i,/^(?:(;))/i,/^(?:(>))/i,/^(?:(<))/i,/^(?:(>=))/i,/^(?:(<=))/i,/^(?:(==))/i,/^(?:(!=))/i,/^(?:(!))/i,/^(?:(%))/i,/^(?:(\\*\\*))/i,/^(?:(if))/i,/^(?:(console\\.log))/i,/^(?:(true))/i,/^(?:([0-9]+(\\.[0-9]+)))/i,/^(?:([0-9]+))/i,/^(?:(\"[^\\\"]*\"))/i,/^(?:('[^\\\"]*'))/i,/^(?:(`[^\\\"]*`))/i,/^(?:\\s+)/i,/^(?:\\/\\/.*)/i,/^(?:[/][*][^*]*[*]+([^/*][^*]*[*]+)*[/])/i,/^(?:$)/i,/^(?:.)/i],\nconditions: {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30],\"inclusive\":true}}\n});\nreturn lexer;\n})();\nparser.lexer = lexer;\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = grammar;\nexports.Parser = grammar.Parser;\nexports.parse = function () { return grammar.parse.apply(grammar, arguments); };\nexports.main = function commonjsMain (args) {\n    if (!args[1]) {\n        console.log('Usage: '+args[0]+' FILE');\n        process.exit(1);\n    }\n    var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\n    return exports.parser.parse(source);\n};\nif (typeof module !== 'undefined' && require.main === module) {\n  exports.main(process.argv.slice(1));\n}\n}","/*\r\nfunction pr2(a, b) {  \r\n    return a + b;\r\n  }\r\n\r\nexport const prb = pr2;\r\n\r\n*/\r\n\r\n\r\n// Constantes para los tipos de 'valoresult' que reconoce nuestra gramática.\r\nconst tIPO_VALOR = {\r\n\tNUMERO:         'VAL_NUMERO',\r\n\tIDENTIFICADOR:  'VAL_IDENTIFICADOR',\r\n\tCADENA:         'VAL_CADENA',\r\n}\r\n\r\n// Constantes para los tipos de 'operaciones' que soporta nuestra gramática.\r\nconst tIPO_OPERACION = {\r\n\tSUMA:           'OP_SUMA',\r\n\tRESTA:          'OP_RESTA',\r\n\tMULTIPLICACION: 'OP_MULTIPLICACION',\r\n\tDIVISION:       'OP_DIVISION',\r\n\tMODULAR:\t\t'MODULAR',\r\n\tEXPONENTE:\t\t'OP_EXPONENTE',\r\n\tNEGATIVO:       'OP_NEGATIVO',\r\n\tMAYOR_QUE:      'OP_MAYOR_QUE',\r\n\tMENOR_QUE:      'OP_MENOR_QUE',\r\n\r\n\tMAYOR_IGUAL: \t'OP_MAYOR_IGUAL',\r\n\tMENOR_IGUAL:    'OP_MENOR_IGUAL',\r\n\tDOBLE_IGUAL:    'OP_DOBLE_IGUAL',\r\n\tNO_IGUAL:    \t'OP_NO_IGUAL',\r\n\r\n\tAND:  \t\t\t'OP_AND',\r\n\tOR: \t\t\t'OP_OR',\r\n\tNOT:   \t\t\t'OP_NOT',  \t\r\n\r\n\tCONCATENACION:  'OP_CONCATENACION'\r\n};\r\n\r\n// Constantes para los tipos de 'instrucciones' válidas en nuestra gramática.\r\nconst tIPO_INSTRUCCION = {\r\n\tIMPRIMIR:\t\t'INSTR_IMPRIMIR',\r\n\tMIENTRAS:\t\t'INSTR_MIENTRAS',\r\n\tDECLARACION:\t'INSTR_DECLARACION',\r\n\tASIGNACION:\t\t'INSTR_ASIGANCION',\r\n\tIF:\t\t\t\t'INSTR_IF',\r\n\tIF_ELSE:\t\t'INSTR_ELSE',\r\n\tPARA: \t\t\t'INST_PARA',\r\n\tSWITCH:\t\t\t'SWITCH',\r\n\tSWITCH_OP:\t\t'SWITCH_OP',\r\n\tSWITCH_DEF:\t\t'SWITCH_DEF',\r\n\tASIGNACION_SIMPLIFICADA: 'ASIGNACION_SIMPLIFICADA'\r\n}\r\n\r\n// Constantes para los tipos de OPCION_SWITCH validas en la gramática\r\nconst tIPO_OPCION_SWITCH = { \r\n\tCASO: \t\t\t'CASO',\r\n\tDEFECTO: \t\t'DEFECTO'\r\n} \r\n\r\n/**\r\n * Esta función se encarga de crear objetos tipo Operación.\r\n * Recibe como parámetros el operando izquierdo y el operando derecho.\r\n * También recibe como parámetro el tipo del operador\r\n * @param {*} operandoIzq \r\n * @param {*} operandoDer \r\n * @param {*} tipo \r\n */\r\nfunction nuevaOperacion(operandoIzq, operandoDer, tipo) {\r\n\treturn {\r\n\t\toperandoIzq: operandoIzq,\r\n\t\toperandoDer: operandoDer,\r\n\t\ttipo: tipo\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * El objetivo de esta API es proveer las funciones necesarias para la construcción de operaciones e instrucciones.\r\n */\r\nconst InstruccionesAPI = {\r\n\r\n\t/**\r\n\t * Crea un nuevo objeto tipo Operación para las operaciones binarias válidas.\r\n\t * @param {*} operandoIzq \r\n\t * @param {*} operandoDer \r\n\t * @param {*} tipo \r\n\t */\r\n\tnuevoOperacionBinaria: function(operandoIzq, operandoDer, tipo) {\r\n\t\treturn nuevaOperacion(operandoIzq, operandoDer, tipo);\r\n\t},\r\n\r\n\t/**\r\n\t * Crea un nuevo objeto tipo Operación para las operaciones unarias válidas\r\n\t * @param {*} operando \r\n\t * @param {*} tipo \r\n\t */\r\n\tnuevoOperacionUnaria: function(operando, tipo) {\r\n\t\treturn nuevaOperacion(operando, undefined, tipo);\r\n\t},\r\n\r\n\t/**\r\n\t * Crea un nuevo objeto tipo Valor, esto puede ser una cadena, un número o un identificador\r\n\t * @param {*} valor \r\n\t * @param {*} tipo \r\n\t */\r\n\tnuevoValor: function(valor, tipo) {\r\n\t\treturn {\r\n\t\t\ttipo: tipo,\r\n\t\t\tvalor: valor\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Crea un objeto tipo Instrucción para la sentencia Imprimir.\r\n\t * @param {*} expresultionCadena \r\n\t */\r\n\tnuevoImprimir: function(expresultionCadena) {\r\n\t\treturn {\r\n\t\t\ttipo: TIPO_INSTRUCCION.IMPRIMIR,\r\n\t\t\texpresultionCadena: expresultionCadena\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Crea un objeto tipo Instrucción para la sentencia Mientras.\r\n\t * @param {*} expresultionLogica \r\n\t * @param {*} instrucciones \r\n\t */\r\n\tnuevoMientras: function(expresultionLogica, instrucciones) {\r\n\t\treturn {\r\n\t\t\ttipo: TIPO_INSTRUCCION.MIENTRAS,\r\n\t\t\texpresultionLogica: expresultionLogica,\r\n\t\t\tinstrucciones: instrucciones\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Crea un objeto tipo instrucción para la sentencia Para.\r\n\t * @param {*} expresultionLogica\r\n\t * @param {*} instrucciones\r\n\t * @param {*} aumento\r\n\t * @param {*} decremento\r\n\t */\r\n\tnuevoPara: function (variable, valorVariable, expresultionLogica, aumento, instrucciones) {\r\n\t\treturn {\r\n\t\t\ttipo: TIPO_INSTRUCCION.PARA,\r\n\t\t\texpresultionLogica: expresultionLogica,\r\n\t\t\tinstrucciones: instrucciones,\r\n\t\t\taumento: aumento,\r\n\t\t\tvariable: variable,\r\n\t\t\tvalorVariable: valorVariable\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Crea un objeto tipo Instrucción para la sentencia Declaración.\r\n\t * @param {*} identificador \r\n\t */\r\n\tnuevoDeclaracion: function(identificador, tipo) {\r\n\t\treturn {\r\n\t\t\ttipo: TIPO_INSTRUCCION.DECLARACION,\r\n\t\t\tidentificador: identificador,\r\n\t\t\ttipo_dato: tipo\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Crea un objeto tipo Instrucción para la sentencia Asignación.\r\n\t * @param {*} identificador \r\n\t * @param {*} expresultionNumerica \r\n\t */\r\n\tnuevoAsignacion: function(identificador, expresultionNumerica) {\r\n\t\treturn {\r\n\t\t\ttipo: TIPO_INSTRUCCION.ASIGNACION,\r\n\t\t\tidentificador: identificador,\r\n\t\t\texpresultionNumerica: expresultionNumerica\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Crea un objeto tipo Instrucción para la sentencia If.\r\n\t * @param {*} expresultionLogica \r\n\t * @param {*} instrucciones \r\n\t */\r\n\tnuevoIf: function(expresultionLogica, instrucciones) {\r\n\t\treturn {\r\n\t\t\ttipo: TIPO_INSTRUCCION.IF,\r\n\t\t\texpresultionLogica: expresultionLogica,\r\n\t\t\tinstrucciones: instrucciones\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Crea un objeto tipo Instrucción para la sentencia If-Else.\r\n\t * @param {*} expresultionLogica \r\n\t * @param {*} instruccionesIfVerdadero \r\n\t * @param {*} instruccionesIfFalso \r\n\t */\r\n\tnuevoIfElse: function(expresultionLogica, instruccionesIfVerdadero, instruccionesIfFalso) {\r\n\t\treturn {\r\n\t\t\ttipo: TIPO_INSTRUCCION.IF_ELSE,\r\n\t\t\texpresultionLogica: expresultionLogica,\r\n\t\t\tinstruccionesIfVerdadero: instruccionesIfVerdadero,\r\n\t\t\tinstruccionesIfFalso: instruccionesIfFalso\r\n\t\t}\r\n\t},\r\n  \r\n\t/**\r\n\t * Crea un objeto tipo Instrucción para la sentencia Switch.\r\n\t * @param {*} expresultionNumerica \r\n\t * @param {*} instrucciones \r\n\t */\r\n\tnuevoSwitch: function(expresultionNumerica, casos) {\r\n\t\treturn {\r\n\t\t\ttipo: TIPO_INSTRUCCION.SWITCH,\r\n\t\t\texpresultionNumerica: expresultionNumerica,\r\n\t\t\tcasos: casos\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Crea una lista de casos para la sentencia Switch.\r\n\t * @param {*} caso \r\n\t */\r\n\tnuevoListaCasos: function (caso) {\r\n\t\tvar casos = []; \r\n\t\tcasos.push(caso);\r\n\t\treturn casos;\r\n\t},\r\n\r\n\t/**\r\n\t * Crea un objeto tipo OPCION_SWITCH para una CASO de la sentencia switch.\r\n\t * @param {*} expresultionNumerica \r\n\t * @param {*} instrucciones \r\n\t */\r\n\tnuevoCaso: function(expresultionNumerica, instrucciones) {\r\n\t\treturn {\r\n\t\t\ttipo: TIPO_OPCION_SWITCH.CASO,\r\n\t\t\texpresultionNumerica: expresultionNumerica,\r\n\t\t\tinstrucciones: instrucciones\r\n\t\t}\r\n\t},\r\n\t/**\r\n\t * Crea un objeto tipo OPCION_SWITCH para un CASO DEFECTO de la sentencia switch.\r\n\t * @param {*} instrucciones \r\n\t */\r\n\tnuevoCasoDef: function(instrucciones) {\r\n\t\treturn {\r\n\t\t\ttipo: TIPO_OPCION_SWITCH.DEFECTO,\r\n\t\t\tinstrucciones: instrucciones\r\n\t\t}\r\n\t},\r\n    \r\n\t/**\r\n\t* Crea un objeto tipo Operador (+ , - , / , *) \r\n\t* @param {*} operador \r\n\t*/\r\n\tnuevoOperador: function(operador){\r\n\t\treturn operador \r\n\t},\r\n \r\n\t/**\r\n\t * Crea un objeto tipo Instrucción para la sentencia Asignacion con Operador\r\n\t * @param {*} identificador \r\n\t * @param {*} operador \r\n\t * @param {*} expresultionCadena \r\n\t */\r\n\tnuevoAsignacionSimplificada: function(identificador, operador , expresultionNumerica){\r\n\t\treturn{\r\n\t\t\ttipo: TIPO_INSTRUCCION.ASIGNACION_SIMPLIFICADA,\r\n\t\t\toperador : operador,\r\n\t\t\texpresultionNumerica: expresultionNumerica,\r\n\t\t\tidentificador : identificador\r\n\t\t} \r\n\t}\r\n}\r\n// Exportamos nuestras constantes y nuestra API\r\n\r\n\r\nexport const TIPO_OPERACION = tIPO_OPERACION;\r\nexport const TIPO_INSTRUCCION = tIPO_INSTRUCCION;\r\nexport const TIPO_VALOR = tIPO_VALOR;\r\nexport const instruccionesAPI = InstruccionesAPI;\r\nexport const TIPO_OPCION_SWITCH = tIPO_OPCION_SWITCH;\r\n","import { TIPO_OPERACION, TIPO_VALOR, TIPO_INSTRUCCION } from './instrucciones';\r\nimport { TIPO_DATO } from './tabla_simbolos';\r\n\r\n//const tsGlobal = new TS([]);\r\n\r\nfunction _main(AST: any) {\r\n  return recorrerAST(AST);\r\n}\r\n\r\nfunction recorrerAST(instrucciones: any) {\r\n  console.log(instrucciones);\r\n  return procesarExpresultionNumerica(instrucciones).valor;\r\n\r\n}\r\n\r\n\r\nfunction procesarExpresultionNumerica(expresultion: any) {\r\n  if (expresultion.tipo === TIPO_OPERACION.NEGATIVO) {\r\n    // Es un valor negado.\r\n    // En este caso necesitamos procesar el valor del operando para poder negar su valor.\r\n    // Para esto invocamos (recursivamente) esta función para sesolver el valor del operando.\r\n    const valor = procesarExpresultionNumerica(expresultion.operandoIzq).valor;     // resultolvemos el operando\r\n    const result = valor * -1;  // Retornamos el valor negado.\r\n    return { valor: result, tipo: TIPO_DATO.NUMERO };\r\n  } else\r\n    if (expresultion.tipo == TIPO_OPERACION.SUMA\r\n      || expresultion.tipo === TIPO_OPERACION.RESTA\r\n      || expresultion.tipo === TIPO_OPERACION.MULTIPLICACION\r\n      || expresultion.tipo === TIPO_OPERACION.DIVISION\r\n      || expresultion.tipo === TIPO_OPERACION.EXPONENTE\r\n      || expresultion.tipo === TIPO_OPERACION.MODULAR) {\r\n      console.log(expresultion);\r\n      //console.log(sumar);\r\n      let valorIzq = procesarExpresultionNumerica(expresultion.operandoIzq);      // resultolvemos el operando izquierdo.\r\n      let valorDer = procesarExpresultionNumerica(expresultion.operandoDer);      // resultolvemos el operando derecho.\r\n\r\n      if (valorIzq.tipo !== TIPO_DATO.NUMERO || valorDer.tipo !== TIPO_DATO.NUMERO) {\r\n        throw 'ERROR: se esperaban expresultiones numericas para ejecutar la: ' + expresultion.tipo;\r\n      } else {\r\n        valorIzq = valorIzq.valor;\r\n        valorDer = valorDer.valor;\r\n      }\r\n\r\n      /* operar la expresultion aritmetica*/\r\n      if (expresultion.tipo == TIPO_OPERACION.SUMA) {\r\n        const result = valorIzq + valorDer;\r\n        return { valor: result, tipo: TIPO_DATO.NUMERO };\r\n      }\r\n      if (expresultion.tipo === TIPO_OPERACION.RESTA) {\r\n        const result = valorIzq - valorDer;\r\n        return { valor: result, tipo: TIPO_DATO.NUMERO };\r\n      }\r\n      if (expresultion.tipo === TIPO_OPERACION.MULTIPLICACION) {\r\n        const result = valorIzq * valorDer;\r\n        return { valor: result, tipo: TIPO_DATO.NUMERO };\r\n      }\r\n      if(expresultion.tipo === TIPO_OPERACION.MODULAR){\r\n        const result = valorIzq % valorDer;\r\n        return { valor: result, tipo: TIPO_DATO.NUMERO };\r\n      }\r\n      if (expresultion.tipo === TIPO_OPERACION.DIVISION) {\r\n        if (valorDer === 0) {\r\n          throw 'ERROR: la division entre 0 da como resultultado: ' + valorIzq / valorDer;\r\n        } else {\r\n          const result = valorIzq / valorDer;\r\n          return { valor: result, tipo: TIPO_DATO.NUMERO };\r\n        }\r\n      }\r\n      if(expresultion.tipo === TIPO_OPERACION.EXPONENTE){\r\n        const resultult = Math.pow(valorIzq, valorDer);\r\n        return { valor: resultult, tipo: TIPO_DATO.NUMERO };\r\n      }\r\n\r\n    } else if (expresultion.tipo == TIPO_VALOR.NUMERO) {\r\n      // Es un valor numérico.\r\n      // En este caso únicamente retornamos el valor obtenido por el parser directamente.\r\n      return { valor: expresultion.valor, tipo: TIPO_DATO.NUMERO }\r\n    } else if (expresultion.tipo === TIPO_VALOR.IDENTIFICADOR) {\r\n      // Es un identificador.\r\n      // Obtenemos el valor de la tabla de simbolos\r\n      //const sym = tablaDeSimbolos.obtener(expresultion.valor);\r\n      //return {valor: sym.valor, tipo: sym.tipo};\r\n    } else {\r\n      throw 'ERROR: expresultión numérica no válida: ' + expresultion;\r\n    }\r\n}\r\n\r\nexport const ejecutar = _main;\r\n","\r\n// Constantes para los tipos de datos.\r\nconst tIPO_DATO = {\r\n    NUMERO: 'NUMERO',\r\n    STRING: 'STRING'\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\nexport const TIPO_DATO = tIPO_DATO;","import { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-navegation',\n  templateUrl: './navegation.component.html',\n  styleUrls: ['./navegation.component.css']\n})\nexport class NavegationComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit(): void {\n\n  }\n\n  btnTraducir() {\n    // (<HTMLInputElement>document.getElementById(\"idEjecutar\")).value = entrada;\n    try {\n    } catch (error) {\n        \n    }\n\n  }\n\n  btnEjecutar() {\n\n  \n  }\n\n  btnReportes() {\n    window.alert(\"boton reportes\");\n  }\n\n  btnTablaSimbolo() {\n    window.alert(\"boton tabla de simbolos\");\n  }\n\n  btnGraficar() {\n    window.alert(\"boton AST\");\n  }\n\n}\n","<nav class=\"navbar navbar-expand-lg navbar-dark bg-dark\">\n    <div class=\"container\">\n        <button class=\"navbar-toggler\" type=\"button\" data-toggle=\"collapse\" data-target=\"#navbarTogglerDemo01\"\n            aria-controls=\"navbarTogglerDemo01\" aria-expanded=\"false\" aria-label=\"Toggle navigation\">\n            <span class=\"navbar-toggler-icon\"></span>\n        </button>\n        <div class=\"collapse navbar-collapse\" id=\"navbarTogglerDemo01\">\n            <a class=\"navbar-brand\">COMPILADOresult 2</a>\n            <ul class=\"navbar-nav ml-auto mt-2 mt-lg-0\">\n                <li class=\"nav-item active\">\n                    <button type=\"button\" class=\"btn btn-success\" (click)=\"btnTraducir()\">traducir</button>\n                </li>\n                <li class=\"nav-item\">\n                    <button type=\"button\" class=\"btn btn-warning\" (click)=\"btnEjecutar()\">ejecutar</button>\n                </li>\n                <li class=\"nav-item\">\n                    <button type=\"button\" class=\"btn btn-primary\" (click)=\"btnReportes()\">reportes</button>\n                </li>\n                <li class=\"nav-item\">\n                    <button type=\"button\" class=\"btn btn-outline-warning\" (click)=\"btnTablaSimbolo()\">tabla de\n                        simbolo</button>\n                </li>\n                <li class=\"nav-item\">\n                    <button type=\"button\" class=\"btn btn-info\" (click)=\"btnGraficar()\">GRAFICAR</button>\n                </li>\n            </ul>\n        </div>\n    </div>\n</nav>","import { Component, OnInit } from '@angular/core';\nimport Parser from '../interprete/grammar';\nimport *as  interprete from '../interprete/recorridoAST';\n\n@Component({\n  selector: 'app-traductor',\n  templateUrl: './traductor.component.html',\n  styleUrls: ['./traductor.component.css']\n})\nexport class TraductorComponent implements OnInit {\n  txtEntrada = \"\";\n  txtConsola = \"\";\n  txtEjecutar = \"\";\n\n  AST: any;\n\n  codeMirror_options: any = {\n    lineNumbers: true,\n    theme: 'dracula',\n    //theme :'mbo',\n    lineWrapping: true,\n    indentWithTabs: true,\n    mode: 'xml',\n    styleActiveLine: true\n  };\n  constructor() { }\n\n  ngOnInit(): void {\n  }\n\n  btnTraducir() {\n    try {\n      this.AST = Parser.parse(this.txtEntrada);\n      this.txtConsola = \"\" + interprete.ejecutar(this.AST);\n      (<HTMLInputElement>document.getElementById(\"idConsola\")).value = this.txtConsola;\n    } catch (error) {\n\n    }\n  }\n\n  btnEjecutar() {\n\n  }\n\n}\n","<div class=\"form-row\">\n    <div class=\"col p-8\">\n        <div class=\"p-1 mb-2 bg-info text-white\">\n            <button type=\"button\" class=\"btn btn-outline-warning\" (click)=\"btnTraducir()\">traducir</button>\n        </div>\n        <div class=\"ngx-codemirror\">\n            <ngx-codemirror [options]=\"codeMirror_options\" [(ngModel)]=\"txtEntrada\" [disabled]=\"false\"\n                [autoFocus]=\"true\"></ngx-codemirror>\n        </div>\n    </div>\n    <div class=\"col\">\n        <div class=\"p-1 mb-1 bg-info text-white\">\n            <button type=\"button\" class=\"btn btn-outline-warning\" (click)=\"btnEjecutar()\">ejecutar</button>\n        </div>\n        <ngx-codemirror [options]=\"codeMirror_options\" [(ngModel)]=\"txtEjecutar\" [disabled]=\"false\" [autoFocus]=\"true\">\n        </ngx-codemirror>\n    </div>\n</div>\n\n\n\n<div class=\"form-row\">\n    <div class=\"col p-2\">\n        <br>\n        <div class=\"p-2 mb-0 bg-dark text-white\">CONSOLA</div>\n        <!-- <ngx-codemirror [options]=\"codeMirror_options\" [(ngModel)]=\"txtConsola\" [disabled] = \"true\"></ngx-codemirror> -->\n        <textarea class=\"form-control console\" id=\"idConsola\" rows=\"9\" [disabled]=\"true\"></textarea>\n    </div>\n</div>","// This file can be replaced during build by using the `fileReplacements` array.\n// `ng build --prod` replaces `environment.ts` with `environment.prod.ts`.\n// The list of file replacements can be found in `angular.json`.\n\nexport const environment = {\n  production: false\n};\n\n/*\n * For easier debugging in development mode, you can import the following file\n * to ignore zone related error stack frames such as `zone.run`, `zoneDelegate.invokeTask`.\n *\n * This import should be commented out in production mode because it will have a negative impact\n * on performance if an error is thrown.\n */\n// import 'zone.js/dist/zone-error';  // Included with Angular CLI.\n","import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\nimport 'codemirror/mode/javascript/javascript';\nimport 'codemirror/mode/markdown/markdown';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n","/* (ignored) */","/* (ignored) */"],"sourceRoot":"webpack:///"}